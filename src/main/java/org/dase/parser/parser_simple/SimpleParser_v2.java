/* SimpleParser_v2.java */
/* Generated By:JavaCC: Do not edit this line. SimpleParser_v2.java */
/* This file is part of the OWL API.
 * The contents of this file are subject to the LGPL License, Version 3.0.
 * Copyright 2014, The University of Manchester
 * 
 * This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License along with this program.  If not, see http://www.gnu.org/licenses/.
 *
 * Alternatively, the contents of this file may be used under the terms of the Apache License, Version 2.0 in which case, the provisions of the Apache License Version 2.0 are applicable instead of those above.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */

package org.dase.parser.parser_simple;

import java.util.Set;
import java.util.HashSet;
import java.util.*;

import org.dase.core.SharedDataHolder;
import org.dase.datastructure.CandidateClass;
import org.dase.datastructure.CandidateSolution;
import org.dase.datastructure.ConjunctiveHornClause;
import org.semanticweb.owlapi.vocab.OWLRDFVocabulary;
import org.semanticweb.owlapi.util.*;

import org.semanticweb.owlapi.model.*;

@SuppressWarnings("all")
public class SimpleParser_v2 implements SimpleParser_v2Constants {
    private String defaultNamespace = IRI.create("http://www.semanticweb.org/ontologies/Ontology").toString();
    private Map<String, String> namespaceMap = new HashMap<String, String>();
    private OWLDataFactory factory;
    private Map<String, IRI> iriMap = new HashMap<String, IRI>();
    private Map<String, IRI> qnameIRIMap = new HashMap<String, IRI>();
    private Set<OWLAxiom> axioms = new LinkedHashSet<OWLAxiom>();
    private int a;
    private static boolean negationHappened = false;

    public void setOWLDataFactory(OWLDataFactory factory) {
        this.factory = factory;
    }

    public void setPrefixMapping(String prefix, String namespace) {
        namespaceMap.put(prefix, namespace);
    }

    public void setDefaultNamespace(String ns) {
        defaultNamespace = ns;
    }

    public IRI getIRI(String val) {
        IRI iri = iriMap.get(val);
        if(iri == null) {
            iri = IRI.create(val);
            iriMap.put(val, iri);
        }
        return iri;
    }

    public IRI getIRIFromId(String qname) {
        if(qname.equals("top") || qname.equals("\u22a4")) {
            return OWLRDFVocabulary.OWL_THING.getIRI();
        }
        if(qname.equals("bottom") || qname.equals("\u22a5")) {
            return OWLRDFVocabulary.OWL_NOTHING.getIRI();
        }
        IRI iri = qnameIRIMap.get(qname);
        if(iri == null) {
            iri = getIRI(defaultNamespace + "#" + qname);
            qnameIRIMap.put(qname, iri);
        }
        return iri;
    }
    private void addAxiom(OWLAxiom ax) {
        if (ax == null) {
          return;
        }
        axioms.add(ax);
    }

/*
 * <pre>
 *   Candidate solution is of the form:
 *
 *   l
 * A ⊓ 􏰃∃Ri.Ci,
 *   i=1
 *    which can  also be written as:
 *   k3       k2
 * A ⊓ 􏰃∃Ri. 􏰀(⊔(Bji ⊓¬(D1 ⊔...⊔Dji)))
 *   i=1    j=1
 *
 *   here,
 *   k3 = limit of object properties considered. = ConfigParams.objPropsCombinationLimit
 *   k2 = limit of horn clauses. = ConfigParams.hornClauseLimit.
 *
 *   As the solution follows this grammer, it has severe limitation:
 *   1. No. of Bare Class (like A) can be at-most 1. We are not allowing A ⊓ B, where both A and B are bare types. If we omit this, we will have to verify the grouping of the solution again.
 *   2. For single object property, we can have multiple horn clause which will be used as OR,
 *              for example: ∃objProp1.((posClass1) ⊔ (posClass2))
 *   3. For multilpe object property, each property will be used as AND,
 *              for example: ∃objProp2.(posClass2) ⊓ ∃objProp1.(posClass1)
 * </pre>

        Grammer:
        CandidateSolution = (CandidateClass) ( AND CandidateClass)*
        ------------
        CandidateClass = PosClass |
                         NOT NegClass |
                         SOME objProp DOT PosClass |
                         SOME objProp DOT NOT NegClass |
                         (ConjunctiveHornClause) ( OR ConjunctiveHornClause)* | // without object properties and without bracket
                         "(" (ConjunctiveHornClause) ( OR ConjunctiveHornClause)* ")" | // without object properties and with bracket
                         SOME objProp DOT "(" (ConjunctiveHornClause) ( OR ConjunctiveHornClause)* ")" | // with object properties and with bracket
                         SOME objProp DOT NOT "(" (ConjunctiveHornClause) ( OR ConjunctiveHornClause)* ")" | // with object properties and with bracket
        --------------
        ConjunctiveHornClause = Class |  // may be positive or negative!!!!!!!!!!
                              = PosClass AND NegClasses |
                              = "(" PosClass AND NegClasses ")" |
                              = NegClasses
        --------------
        NegClasses = NOT NegClass |
                   = NOT "(" NegClass ( OR NegClass )* ")"
 */
  final public 
CandidateSolution parseCandidateSolution() throws ParseException {CandidateSolution candidateSolution = new CandidateSolution();
    CandidateClass candidateClass = null;
    candidateClass = parseCandidateClass();
candidateSolution.addCandidateClass(candidateClass);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case AND:{
        ;
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      jj_consume_token(AND);
      candidateClass = parseCandidateClass();
candidateSolution.addCandidateClass(candidateClass);
    }
    jj_consume_token(0);
{if ("" != null) return candidateSolution;}
    throw new Error("Missing return statement in function");
  }

  final public CandidateClass parseCandidateClass() throws ParseException {CandidateClass candidateClass = null;
    ConjunctiveHornClause conjunctiveHornClause = null;
    OWLClassExpression owlClassExpression;
    OWLObjectProperty owlObjectProperty = null;
    if (jj_2_2(6)) {
      jj_consume_token(NOT);
      owlClassExpression = parseClassId();
conjunctiveHornClause = new ConjunctiveHornClause(SharedDataHolder.noneOWLObjProp);
        conjunctiveHornClause.addNegObjectType(owlClassExpression);
        candidateClass = new CandidateClass(SharedDataHolder.noneOWLObjProp);
        candidateClass.addConjunctiveHornClauses(conjunctiveHornClause);
    } else if (jj_2_3(6)) {
      jj_consume_token(SOME);
      owlObjectProperty = parseObjectPropertyId();
      jj_consume_token(DOT);
      owlClassExpression = parseClassId();
conjunctiveHornClause = new ConjunctiveHornClause(owlObjectProperty);
    conjunctiveHornClause.setPosObjectType(owlClassExpression);
    candidateClass = new CandidateClass(owlObjectProperty);
    candidateClass.addConjunctiveHornClauses(conjunctiveHornClause);
    } else if (jj_2_4(6)) {
      jj_consume_token(SOME);
      owlObjectProperty = parseObjectPropertyId();
      jj_consume_token(DOT);
      jj_consume_token(NOT);
      owlClassExpression = parseClassId();
conjunctiveHornClause = new ConjunctiveHornClause(owlObjectProperty);
    conjunctiveHornClause.addNegObjectType(owlClassExpression);
    candidateClass = new CandidateClass(owlObjectProperty);
    candidateClass.addConjunctiveHornClauses(conjunctiveHornClause);
    } else if (jj_2_5(6)) {
      conjunctiveHornClause = parseConjunctiveHornClause(SharedDataHolder.noneOWLObjProp,false);
candidateClass = new CandidateClass(SharedDataHolder.noneOWLObjProp);
    candidateClass.addConjunctiveHornClauses(conjunctiveHornClause);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OR:{
          ;
          break;
          }
        default:
          jj_la1[1] = jj_gen;
          break label_2;
        }
        jj_consume_token(OR);
        conjunctiveHornClause = parseConjunctiveHornClause(SharedDataHolder.noneOWLObjProp,false);
//    candidateClass = new CandidateClass(SharedDataHolder.noneOWLObjProp);
    candidateClass.addConjunctiveHornClauses(conjunctiveHornClause);
      }
    } else if (jj_2_6(6)) {
      jj_consume_token(OPENPAR);
      conjunctiveHornClause = parseConjunctiveHornClause(SharedDataHolder.noneOWLObjProp,false);
candidateClass = new CandidateClass(SharedDataHolder.noneOWLObjProp);
    candidateClass.addConjunctiveHornClauses(conjunctiveHornClause);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OR:{
          ;
          break;
          }
        default:
          jj_la1[2] = jj_gen;
          break label_3;
        }
        jj_consume_token(OR);
        conjunctiveHornClause = parseConjunctiveHornClause(SharedDataHolder.noneOWLObjProp,false);
//    candidateClass = new CandidateClass(SharedDataHolder.noneOWLObjProp);
    candidateClass.addConjunctiveHornClauses(conjunctiveHornClause);
      }
      jj_consume_token(CLOSEPAR);
    } else if (jj_2_7(6)) {
      jj_consume_token(SOME);
      owlObjectProperty = parseObjectPropertyId();
      jj_consume_token(DOT);
      jj_consume_token(OPENPAR);
      conjunctiveHornClause = parseConjunctiveHornClause(owlObjectProperty,false);
candidateClass = new CandidateClass(owlObjectProperty);
    candidateClass.addConjunctiveHornClauses(conjunctiveHornClause);
      label_4:
      while (true) {
        if (jj_2_1(6)) {
          ;
        } else {
          break label_4;
        }
        jj_consume_token(OR);
        conjunctiveHornClause = parseConjunctiveHornClause(owlObjectProperty,false);
//    candidateClass = new CandidateClass(owlObjectProperty);
    candidateClass.addConjunctiveHornClauses(conjunctiveHornClause);
      }
      jj_consume_token(CLOSEPAR);

    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SOME:{
        jj_consume_token(SOME);
        owlObjectProperty = parseObjectPropertyId();
        jj_consume_token(DOT);
        jj_consume_token(NOT);
        jj_consume_token(OPENPAR);
        conjunctiveHornClause = parseConjunctiveHornClause(owlObjectProperty,true);
//    candidateClass = new CandidateClass(owlObjectProperty);
    candidateClass.addConjunctiveHornClauses(conjunctiveHornClause);
        label_5:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case OR:{
            ;
            break;
            }
          default:
            jj_la1[3] = jj_gen;
            break label_5;
          }
          jj_consume_token(OR);
          conjunctiveHornClause = parseConjunctiveHornClause(owlObjectProperty,true);
//    candidateClass = new CandidateClass(owlObjectProperty);
    candidateClass.addConjunctiveHornClauses(conjunctiveHornClause);
        }
        jj_consume_token(CLOSEPAR);

        break;
        }
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return candidateClass;}
    throw new Error("Missing return statement in function");
  }

  final public ConjunctiveHornClause parseConjunctiveHornClause(OWLObjectProperty owlObjectProperty,boolean isNegative) throws ParseException {ConjunctiveHornClause conjunctiveHornClause = new ConjunctiveHornClause(owlObjectProperty);
    ArrayList<OWLClassExpression> negTypes = new ArrayList<OWLClassExpression>();
    OWLClassExpression owlClassExpression;
    if (jj_2_8(6)) {
      owlClassExpression = parseClassId();
if(isNegative) { conjunctiveHornClause.addNegObjectType(owlClassExpression);} else{ conjunctiveHornClause.setPosObjectType(owlClassExpression);}
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ID:{
        owlClassExpression = parseClassId();
conjunctiveHornClause.setPosObjectType(owlClassExpression);
        jj_consume_token(AND);
        parseNegClasses();
for(OWLClassExpression negType: negTypes) { conjunctiveHornClause.addNegObjectType(negType); }
        break;
        }
      case OPENPAR:{
        jj_consume_token(OPENPAR);
        owlClassExpression = parseClassId();
conjunctiveHornClause.setPosObjectType(owlClassExpression);
        jj_consume_token(AND);
        negTypes = parseNegClasses();
for(OWLClassExpression negType: negTypes){ conjunctiveHornClause.addNegObjectType(negType); }
        jj_consume_token(CLOSEPAR);
        break;
        }
      case NOT:{
        negTypes = parseNegClasses();
for(OWLClassExpression negType: negTypes){ conjunctiveHornClause.addNegObjectType(negType); }
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return conjunctiveHornClause;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<OWLClassExpression> parseNegClasses() throws ParseException {ArrayList<OWLClassExpression> negTypes = new ArrayList<OWLClassExpression>();
    OWLClassExpression owlClassExpression;
    if (jj_2_9(6)) {
      jj_consume_token(NOT);
      owlClassExpression = parseClassId();
negTypes.add(owlClassExpression);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NOT:{
        jj_consume_token(NOT);
        jj_consume_token(OPENPAR);
        owlClassExpression = parseClassId();
negTypes.add(owlClassExpression);
        label_6:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case OR:{
            ;
            break;
            }
          default:
            jj_la1[6] = jj_gen;
            break label_6;
          }
          jj_consume_token(OR);
          owlClassExpression = parseClassId();
negTypes.add(owlClassExpression);
        }
        jj_consume_token(CLOSEPAR);
        break;
        }
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return negTypes;}
    throw new Error("Missing return statement in function");
  }

  final public OWLObjectProperty parseObjectPropertyId() throws ParseException {IRI iri;
    boolean inverse = false;
    iri = parseId();
{if ("" != null) return factory.getOWLObjectProperty(iri);}
    throw new Error("Missing return statement in function");
  }

  final public OWLClass parseClassId() throws ParseException {IRI iri;
    iri = parseId();
{if ("" != null) return factory.getOWLClass(iri);}
    throw new Error("Missing return statement in function");
  }

  final public IRI parseId() throws ParseException {Token t;
    t = jj_consume_token(ID);
{if ("" != null) return getIRIFromId(t.image);}
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_3_6()
 {
    if (jj_scan_token(OPENPAR)) return true;
    if (jj_3R_7()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_11()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(CLOSEPAR)) return true;
    return false;
  }

  private boolean jj_3R_10()
 {
    if (jj_scan_token(OR)) return true;
    if (jj_3R_7()) return true;
    return false;
  }

  private boolean jj_3R_14()
 {
    if (jj_3R_16()) return true;
    return false;
  }

  private boolean jj_3_5()
 {
    if (jj_3R_7()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_10()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_13()
 {
    if (jj_scan_token(OPENPAR)) return true;
    if (jj_3R_8()) return true;
    if (jj_scan_token(AND)) return true;
    if (jj_3R_16()) return true;
    if (jj_scan_token(CLOSEPAR)) return true;
    return false;
  }

  private boolean jj_3R_12()
 {
    if (jj_3R_8()) return true;
    if (jj_scan_token(AND)) return true;
    if (jj_3R_16()) return true;
    return false;
  }

  private boolean jj_3_8()
 {
    if (jj_3R_8()) return true;
    return false;
  }

  private boolean jj_3R_7()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_8()) {
    jj_scanpos = xsp;
    if (jj_3R_12()) {
    jj_scanpos = xsp;
    if (jj_3R_13()) {
    jj_scanpos = xsp;
    if (jj_3R_14()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_15()
 {
    if (jj_scan_token(ID)) return true;
    return false;
  }

  private boolean jj_3_4()
 {
    if (jj_scan_token(SOME)) return true;
    if (jj_3R_9()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(NOT)) return true;
    if (jj_3R_8()) return true;
    return false;
  }

  private boolean jj_3_3()
 {
    if (jj_scan_token(SOME)) return true;
    if (jj_3R_9()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_8()) return true;
    return false;
  }

  private boolean jj_3R_8()
 {
    if (jj_3R_15()) return true;
    return false;
  }

  private boolean jj_3R_9()
 {
    if (jj_3R_15()) return true;
    return false;
  }

  private boolean jj_3_2()
 {
    if (jj_scan_token(NOT)) return true;
    if (jj_3R_8()) return true;
    return false;
  }

  private boolean jj_3_1()
 {
    if (jj_scan_token(OR)) return true;
    if (jj_3R_7()) return true;
    return false;
  }

  private boolean jj_3R_18()
 {
    if (jj_scan_token(OR)) return true;
    if (jj_3R_8()) return true;
    return false;
  }

  private boolean jj_3_9()
 {
    if (jj_scan_token(NOT)) return true;
    if (jj_3R_8()) return true;
    return false;
  }

  private boolean jj_3R_17()
 {
    if (jj_scan_token(NOT)) return true;
    if (jj_scan_token(OPENPAR)) return true;
    if (jj_3R_8()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_18()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(CLOSEPAR)) return true;
    return false;
  }

  private boolean jj_3_7()
 {
    if (jj_scan_token(SOME)) return true;
    if (jj_3R_9()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(OPENPAR)) return true;
    if (jj_3R_7()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_1()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(CLOSEPAR)) return true;
    return false;
  }

  private boolean jj_3R_16()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_9()) {
    jj_scanpos = xsp;
    if (jj_3R_17()) return true;
    }
    return false;
  }

  private boolean jj_3R_11()
 {
    if (jj_scan_token(OR)) return true;
    if (jj_3R_7()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public SimpleParser_v2TokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[8];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x20000,0x40000,0x40000,0x40000,0x100000,0x20080400,0x40000,0x80000,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[9];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public SimpleParser_v2(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SimpleParser_v2(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SimpleParser_v2TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public SimpleParser_v2(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new SimpleParser_v2TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public SimpleParser_v2(SimpleParser_v2TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(SimpleParser_v2TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[30];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 8; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 30; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 9; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
