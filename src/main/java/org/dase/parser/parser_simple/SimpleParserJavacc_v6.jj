options {
    STATIC=false;
    JAVA_UNICODE_ESCAPE=true;
    //LOOKAHEAD=2; 
    JAVA_TEMPLATE_TYPE = "modern";
    EXCEPTIONS_SUPER_CLASS = "org.semanticweb.owlapi.io.OWLParserException";
    SUPPORT_CLASS_VISIBILITY_PUBLIC=false;
    OUTPUT_DIRECTORY="/Users/sarker/Workspaces/Jetbrains/residue/java/residue_java_v1/src/main/java/org/dase/parser/parser_simple";
    //DEBUG_PARSER=true;
    //DEBUG_TOKEN_MANAGER=true;
}

PARSER_BEGIN(SimpleParserJavacc_v6)

/* This file is part of the OWL API.
 * The contents of this file are subject to the LGPL License, Version 3.0.
 * Copyright 2014, The University of Manchester
 * 
 * This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License along with this program.  If not, see http://www.gnu.org/licenses/.
 *
 * Alternatively, the contents of this file may be used under the terms of the Apache License, Version 2.0 in which case, the provisions of the Apache License Version 2.0 are applicable instead of those above.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */

package org.dase.parser.parser_simple;

import java.util.Set;
import java.util.HashSet;
import java.util.*;

import org.dase.core.SharedDataHolder;
import org.dase.datastructure.CandidateClassV1;
import org.dase.datastructure.CandidateSolutionV1;
import org.dase.datastructure.ConjunctiveHornClauseV1;
import org.semanticweb.owlapi.reasoner.OWLReasoner;import org.semanticweb.owlapi.vocab.OWLRDFVocabulary;
import org.semanticweb.owlapi.util.*;

import org.semanticweb.owlapi.model.*;

@SuppressWarnings("all")
public class SimpleParserJavacc_v6 {
    private String defaultNamespace = IRI.create("http://www.semanticweb.org/ontologies/Ontology").toString();
    private Map<String, String> namespaceMap = new HashMap<String, String>();
    private OWLDataFactory factory;
    private OWLOntology ontology;
    private OWLReasoner reasoner;
    private Map<String, IRI> iriMap = new HashMap<String, IRI>();
    private Map<String, IRI> qnameIRIMap = new HashMap<String, IRI>();
    private Set<OWLAxiom> axioms = new LinkedHashSet<OWLAxiom>();
    private int a;
    private static boolean negationHappened = false;

    public void initiate(OWLDataFactory factory,OWLOntology ontology, OWLReasoner reasoner) {
        this.factory = factory;
        this.ontology = ontology;
        this.reasoner = reasoner;
    }

    public void setPrefixMapping(String prefix, String namespace) {
        namespaceMap.put(prefix, namespace);
    }

    public void setDefaultNamespace(String ns) {
        defaultNamespace = ns;
    }

    public IRI getIRI(String val) {
        IRI iri = iriMap.get(val);
        if(iri == null) {
            iri = IRI.create(val);
            iriMap.put(val, iri);
        }
        return iri;
    }

    public IRI getIRIFromId(String qname) {
        if(qname.equals("top") || qname.equals("\u22A4")) {
            return OWLRDFVocabulary.OWL_THING.getIRI();
        }
        if(qname.equals("bottom") || qname.equals("\u22A5")) {
            return OWLRDFVocabulary.OWL_NOTHING.getIRI();
        }
        IRI iri = qnameIRIMap.get(qname);
        if(iri == null) {
            iri = getIRI(defaultNamespace + "#" + qname);
            qnameIRIMap.put(qname, iri);
        }
        return iri;
    }

    private void addAxiom(OWLAxiom ax) {
        if (ax == null) {
          return;
        }
        axioms.add(ax);
    }
}

PARSER_END(SimpleParserJavacc_v6)

// We skip over any white space
SKIP: {" " | "\r" | "\t"}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

TOKEN: { <SUBCLASSOF: ("\u2291" | "->" | "sub" | "\\sqsubseteq")> }
TOKEN: { <EQUIVALENTTO: ("\u2261" | "==" | "\\equiv")> }
TOKEN: { <NEQ: ("\u2260" | "!=" | "\\not=")> }
TOKEN: { <COMPOSE: "o" | "\u2218" > }
TOKEN: { <DOT: "."> }
TOKEN: { <INVERSE: "\u207B" | "^-"> }
TOKEN: { <OPENPAR: "("> }
TOKEN: { <CLOSEPAR: ")"> }
TOKEN: { <OPENSQPAR: "["> }
TOKEN: { <CLOSESQPAR: "]"> }
TOKEN: { <OPENBRACE: "{"> }
TOKEN: { <CLOSEBRACE: "}"> }
TOKEN: { <COLON: ":"> }
TOKEN: { <AND: ("\u2293" | "and" | "AND" | "\\sqcap")> }
TOKEN: { <OR: ("\u2294" | "or" | "OR" | "\\sqcup")> }
TOKEN: { <NOT: ("\u00AC" | "not" | "NOT" | "\\lnot")> }
TOKEN: { <SOME: ("\u2203" | "exists" | "EXISTS" | "some" | "SOME" | "\\exists")> }
TOKEN: { <ALL: ("\u2200" | "forall" | "FORALL" | "\\forall")> }
TOKEN: { <MIN: ("\u2265" | ">" | "\\geq")> }
TOKEN: { <MAX: ("\u2264" | "<" | "\\leq")> }
TOKEN: { <EXACT: ("=" | "equal")> }
TOKEN: { <IN: ("in" | "\u2208")> }
TOKEN: { <TRANSITIVEROLES: ("trans" | "transitive" | "R\u207A")> }
TOKEN: { <INT: (["0"-"9"])+> }
TOKEN: { <DOUBLE: (<INT>)+<DOT>(<INT>)*> }
TOKEN: { <ID: ((~[" ", "\n", "\t", "(", ")", "[", "]", "{", "}", ",", "^", "=", "<", ">", ".", "\u207B", "\u00AC", "\u2208"]))+> }


/*
 * <pre>
 * Candidate solution consists of multiple candidate classes. Multiple candidate class are grouped by owlObjectproperty.
 * Each groups are combined by AND/Intersection.
 * Inside the group:
 *  * 1. When we have none ObjectProperty or bare types, then candidate classes will be combined by AND/Intersection
 *  * 2. When we have proper ObjectProperty, then candidate classes will be combined with OR/Disjunction
 *
 *  Example Solution
 *  Candidate solution is of the form:
 *
 *   l
 * A ⊓ 􏰃∃Ri.Ci,
 *   i=1
 *
 *    which can  also be written as:
 *
 *   k3       k2
 * A ⊓ 􏰃∃Ri. 􏰀(⊔(Bji ⊓¬(D1 ⊔...⊔Dji)))
 *   i=1    j=1
 *
 *   here,
 *   k3 = limit of object properties considered. = ConfigParams.objPropsCombinationLimit
 *   k2 = limit of horn clauses. = ConfigParams.hornClauseLimit.
 *
 * An Example
 *  *   Solution = (A1 ⊓ ¬(D1)) ⊓ (A2 ⊓ ¬(D1))  ⊓  R1.( (B1 ⊓ ... ⊓ Bn ⊓ ¬(D1 ⊔...⊔ Djk)) ⊔ (B1 ⊓ ... ⊓ Bn ⊓ ¬(D1 ⊔...⊔ Djk)) ) ⊓ R2.(..)...
 *  *      here, we have 3 groups.
 *  *       group1: with bare objectProperty: (A1 ⊓ ¬(D1)) ⊓ (A2 ⊓ ¬(D1))
 *  *       group2: with R1 objectProperty:   R1.( (B1 ⊓ ... ⊓ Bn ⊓ ¬(D1 ⊔...⊔ Djk)) ⊔ (B1 ⊓ ... ⊓ Bn ⊓ ¬(D1 ⊔...⊔ Djk)) )
 *  *       group3: with R2 objectProperty:   R2.(..)
 *
 *  *   Inside of a group, we have multiple candidateClass
 *  *       multiple candidateClass are conjuncted when we have hare object property, and
 *                                      unioned when we have proper object property.
 *  *       Inside of CandidateClass:
 *  *           multiple horclauses are conjuncted when we have hare object property, and
 *                                      unioned when we have proper object property.
 *
 * * Implementation note:
 * * Atomic class is also added using candidate class. If the object property is empty = SharedDataHolder.noneOWLObjProp then it is atomic class.
 * * it must be the same procedure in both
 *      1. Printing getAsString(
 *      2. calculating accuracy,
 *      3. making getAsOWLClassExpression(
 *  * We will have a single group for a single objectProperty.

        Grammer:
        CandidateSolution = (GroupedCandidateClasses) ( AND GroupedCandidateClasses)*
        ------------
        GroupedCandidateClasses = (CandidateClass) ( AND CandidateClass)* |
                                = SOME objProp DOT (CandidateClassWithProp) ( OR CandidateClassWithProp)*
        ------------
        CandidateClass =  (ConjunctiveHornClause) ( AND ConjunctiveHornClause)* | // without object properties and without bracket
                         "(" (ConjunctiveHornClause) ( AND ConjunctiveHornClause)* ")" | // without object properties and with bracket, if there exist AND then the first
                                                                    "(" should not be consumed here. It is becoming conflicting with ConjunctiveHornClause = "(" PosClasses AND NegClasses ")" for test case 7.
                                                                     By putting and extra parenthesis on test case 7, this rule will work.
        ------------
        CandidateClassWithProp = "(" (ConjunctiveHornClause) ( OR ConjunctiveHornClause)* ")" | // with object properties and with bracket
        --------------
        ConjunctiveHornClause = PosClasses |
                              = PosClasses AND NegClasses |   // lookahead ?? how much? For test case: (A1 ⊓ ¬(D1)) it will try to execute ConjunctiveHornClause = PosClasses,
                                                            rather than this rule, if lookahead is not enforced. lookAhead should be no. of PosClass Limit + 2 (AND NOT)
                              = "(" PosClasses AND NegClasses ")"
        --------------
        PosClasses = PosClass |
                   =  PosClass ( AND PosClass)*    // lookahead 2, 1 for AND, 1 for NOT, so 1+1=2
        NegClasses = NOT "(" NegClass ")"|
                   = NOT "(" NegClass ( OR NegClass )* ")" // lookahead 1

*
* test-case
*   1: A ⊓ B
*   2: R.(A ⊓ B)
*   3. (A1 ⊓ ¬(D1))
*   4: (A1 ⊓ ¬(D1)) ⊓ (A2 ⊓ ¬(D1))
*   5: R.( (A1 ⊓ ¬(D1)) ⊔ (A2 ⊓ ¬(D1)) )
*   6. A ⊓ B ⊓ R2.( (A1 ⊓ ¬(D1)) ⊔ (A2 ⊓ ¬(D1)) )
*   7. (A1 ⊓ ¬(D1)) ⊓ (A2 ⊓ ¬(D1))  ⊓  R1.( (B1 ⊓ ... ⊓ Bn ⊓ ¬(D1 ⊔...⊔ Djk)) ⊔ (B1 ⊓ ... ⊓ Bn ⊓ ¬(D1 ⊔...⊔ Djk)) ) ⊓ R2.(..)
*   7... ( (A1 ⊓ ¬(D1)) ⊓ (A2 ⊓ ¬(D1)) ) ⊓  R1.( (B1 ⊓ ... ⊓ Bn ⊓ ¬(D1 ⊔...⊔ Djk)) ⊔ (B1 ⊓ ... ⊓ Bn ⊓ ¬(D1 ⊔...⊔ Djk)) ) ⊓ R2.(..)
*   8. A
     </pre>
 */

CandidateSolutionV1 parseCandidateSolution() :
{
    CandidateSolutionV1 candidateSolution = new CandidateSolutionV1(reasoner,ontology);
    ArrayList<CandidateClassV1> candidateClasses = new ArrayList<CandidateClassV1>();
 }
{    candidateClasses = GroupedCandidateClasses()
            { if(null != candidateClasses) for(CandidateClassV1 c1: candidateClasses) candidateSolution.addCandidateClass(c1);}
    (<AND> candidateClasses = GroupedCandidateClasses()
            { if(null != candidateClasses) for(CandidateClassV1 c1: candidateClasses) candidateSolution.addCandidateClass(c1); } )*
     <EOF>
    { return candidateSolution; }
}

ArrayList<CandidateClassV1> GroupedCandidateClasses() :
{
    ArrayList<CandidateClassV1> candidateClasses = new ArrayList<CandidateClassV1>();
    CandidateClassV1 candidateClass;
    OWLObjectProperty owlObjectProperty;
}
{
    (
    <SOME>  owlObjectProperty = parseObjectPropertyId() <DOT> candidateClass = parseCandidateClassWithProp(owlObjectProperty)
                     { if(null != candidateClass) candidateClasses.add(candidateClass); }
         ( <OR>  candidateClass = parseCandidateClassWithProp(owlObjectProperty)
                     { if(null != candidateClass) candidateClasses.add(candidateClass); } )*
                         |
     candidateClass = parseCandidateClass(SharedDataHolder.noneOWLObjProp)
                { if(null != candidateClass) candidateClasses.add(candidateClass); }
        ( LOOKAHEAD(2) <AND>  candidateClass = parseCandidateClass(SharedDataHolder.noneOWLObjProp)
                    { if(null != candidateClass) candidateClasses.add(candidateClass); })*
    )
    // why this LOOKAHEAD(2) ? candidateClass also have AND inside, so that AND and this AND* is conflicting. not sure how many lookahead is needed
    { return candidateClasses;}
}

CandidateClassV1 parseCandidateClassWithProp(OWLObjectProperty owlObjectProperty) :
{
    CandidateClassV1 candidateClass = new CandidateClassV1(owlObjectProperty,reasoner,ontology);
    ConjunctiveHornClauseV1 conjunctiveHornClause;
}
{   (<OPENPAR>)? conjunctiveHornClause = parseConjunctiveHornClause(owlObjectProperty) { candidateClass.addConjunctiveHornClauses(conjunctiveHornClause); }
    ( LOOKAHEAD(2) <OR>  conjunctiveHornClause = parseConjunctiveHornClause(owlObjectProperty) { candidateClass.addConjunctiveHornClauses(conjunctiveHornClause); })* (<CLOSEPAR>)?
    {return candidateClass;}
}

CandidateClassV1 parseCandidateClass(OWLObjectProperty owlObjectProperty) :
{
    CandidateClassV1 candidateClass = new CandidateClassV1(owlObjectProperty,reasoner,ontology);
    ConjunctiveHornClauseV1 conjunctiveHornClause;
}
{   (<OPENPAR>)?  conjunctiveHornClause = parseConjunctiveHornClause(owlObjectProperty) { candidateClass.addConjunctiveHornClauses(conjunctiveHornClause); }
        ( LOOKAHEAD(2) <AND>  conjunctiveHornClause = parseConjunctiveHornClause(owlObjectProperty) { candidateClass.addConjunctiveHornClauses(conjunctiveHornClause); })* (<CLOSEPAR>)?
    {  return candidateClass; }
}

ConjunctiveHornClauseV1 parseConjunctiveHornClause(OWLObjectProperty owlObjectProperty) :
{   ConjunctiveHornClauseV1 conjunctiveHornClause = new ConjunctiveHornClauseV1(owlObjectProperty,reasoner,ontology);
    ArrayList<OWLClassExpression> posTypes = new ArrayList<OWLClassExpression>();
    ArrayList<OWLClassExpression> negTypes = new ArrayList<OWLClassExpression>();
}
{  (<OPENPAR>)? (<OPENPAR>)?  posTypes = parsePosClasses() {conjunctiveHornClause.setPosObjectTypes(posTypes);} (<CLOSEPAR>)?
                ( <AND> <NOT> <OPENPAR> negTypes = parseNegClasses() {conjunctiveHornClause.setNegObjectTypes(negTypes);} <CLOSEPAR> )? (<CLOSEPAR> )?
  {return conjunctiveHornClause;}
}

ArrayList<OWLClassExpression> parsePosClasses() :
{
    ArrayList<OWLClassExpression> posTypes = new ArrayList<OWLClassExpression>();
    OWLClassExpression owlClassExpression;
}
{    owlClassExpression = parseClassId() { posTypes.add(owlClassExpression); }   ( <AND> owlClassExpression = parseClassId() { posTypes.add(owlClassExpression); } )*
    { return posTypes; }
}

ArrayList<OWLClassExpression> parseNegClasses() :
{
    ArrayList<OWLClassExpression> negTypes = new ArrayList<OWLClassExpression>();
    OWLClassExpression owlClassExpression;
}
{    owlClassExpression = parseClassId() { negTypes.add(owlClassExpression); }
            ( LOOKAHEAD(2) <OR> owlClassExpression = parseClassId() { negTypes.add(owlClassExpression); } )*
    { return negTypes; }
}


OWLObjectProperty parseObjectPropertyId():
{
    IRI iri;
    boolean inverse = false;
}
{
    iri=parseId() { return factory.getOWLObjectProperty(iri); }
}


OWLClass parseClassId():
{ IRI iri; }
{ iri=parseId() { return factory.getOWLClass(iri); } }

IRI parseId() :
{ Token t; }
{ t=<ID> { return getIRIFromId(t.image); } }
