/* SimpleParserJavacc_v6.java */
/* Generated By:JavaCC: Do not edit this line. SimpleParserJavacc_v6.java */
/* This file is part of the OWL API.
 * The contents of this file are subject to the LGPL License, Version 3.0.
 * Copyright 2014, The University of Manchester
 * 
 * This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License along with this program.  If not, see http://www.gnu.org/licenses/.
 *
 * Alternatively, the contents of this file may be used under the terms of the Apache License, Version 2.0 in which case, the provisions of the Apache License Version 2.0 are applicable instead of those above.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */

package org.dase.parser.parser_simple;

import java.util.Set;
import java.util.HashSet;
import java.util.*;

import org.dase.core.SharedDataHolder;
import org.dase.datastructure.CandidateClassV1;
import org.dase.datastructure.CandidateSolutionV1;
import org.dase.datastructure.ConjunctiveHornClauseV1;
import org.semanticweb.owlapi.reasoner.OWLReasoner;import org.semanticweb.owlapi.vocab.OWLRDFVocabulary;
import org.semanticweb.owlapi.util.*;

import org.semanticweb.owlapi.model.*;

@SuppressWarnings("all")
public class SimpleParserJavacc_v6 implements SimpleParserJavacc_v6Constants {
    private String defaultNamespace = IRI.create("http://www.semanticweb.org/ontologies/Ontology").toString();
    private Map<String, String> namespaceMap = new HashMap<String, String>();
    private OWLDataFactory factory;
    private OWLOntology ontology;
    private OWLReasoner reasoner;
    private Map<String, IRI> iriMap = new HashMap<String, IRI>();
    private Map<String, IRI> qnameIRIMap = new HashMap<String, IRI>();
    private Set<OWLAxiom> axioms = new LinkedHashSet<OWLAxiom>();
    private int a;
    private static boolean negationHappened = false;

    public void initiate(OWLDataFactory factory,OWLOntology ontology, OWLReasoner reasoner) {
        this.factory = factory;
        this.ontology = ontology;
        this.reasoner = reasoner;
    }

    public void setPrefixMapping(String prefix, String namespace) {
        namespaceMap.put(prefix, namespace);
    }

    public void setDefaultNamespace(String ns) {
        defaultNamespace = ns;
    }

    public IRI getIRI(String val) {
        IRI iri = iriMap.get(val);
        if(iri == null) {
            iri = IRI.create(val);
            iriMap.put(val, iri);
        }
        return iri;
    }

    public IRI getIRIFromId(String qname) {
        if(qname.equals("top") || qname.equals("\u22a4")) {
            return OWLRDFVocabulary.OWL_THING.getIRI();
        }
        if(qname.equals("bottom") || qname.equals("\u22a5")) {
            return OWLRDFVocabulary.OWL_NOTHING.getIRI();
        }
        IRI iri = qnameIRIMap.get(qname);
        if(iri == null) {
            iri = getIRI(defaultNamespace + "#" + qname);
            qnameIRIMap.put(qname, iri);
        }
        return iri;
    }

    private void addAxiom(OWLAxiom ax) {
        if (ax == null) {
          return;
        }
        axioms.add(ax);
    }

/*
 * <pre>
 * Candidate solution consists of multiple candidate classes. Multiple candidate class are grouped by owlObjectproperty.
 * Each groups are combined by AND/Intersection.
 * Inside the group:
 *  * 1. When we have none ObjectProperty or bare types, then candidate classes will be combined by AND/Intersection
 *  * 2. When we have proper ObjectProperty, then candidate classes will be combined with OR/Disjunction
 *
 *  Example Solution
 *  Candidate solution is of the form:
 *
 *   l
 * A ⊓ 􏰃∃Ri.Ci,
 *   i=1
 *
 *    which can  also be written as:
 *
 *   k3       k2
 * A ⊓ 􏰃∃Ri. 􏰀(⊔(Bji ⊓¬(D1 ⊔...⊔Dji)))
 *   i=1    j=1
 *
 *   here,
 *   k3 = limit of object properties considered. = ConfigParams.objPropsCombinationLimit
 *   k2 = limit of horn clauses. = ConfigParams.hornClauseLimit.
 *
 * An Example
 *  *   Solution = (A1 ⊓ ¬(D1)) ⊓ (A2 ⊓ ¬(D1))  ⊓  R1.( (B1 ⊓ ... ⊓ Bn ⊓ ¬(D1 ⊔...⊔ Djk)) ⊔ (B1 ⊓ ... ⊓ Bn ⊓ ¬(D1 ⊔...⊔ Djk)) ) ⊓ R2.(..)...
 *  *      here, we have 3 groups.
 *  *       group1: with bare objectProperty: (A1 ⊓ ¬(D1)) ⊓ (A2 ⊓ ¬(D1))
 *  *       group2: with R1 objectProperty:   R1.( (B1 ⊓ ... ⊓ Bn ⊓ ¬(D1 ⊔...⊔ Djk)) ⊔ (B1 ⊓ ... ⊓ Bn ⊓ ¬(D1 ⊔...⊔ Djk)) )
 *  *       group3: with R2 objectProperty:   R2.(..)
 *
 *  *   Inside of a group, we have multiple candidateClass
 *  *       multiple candidateClass are conjuncted when we have hare object property, and
 *                                      unioned when we have proper object property.
 *  *       Inside of CandidateClass:
 *  *           multiple horclauses are conjuncted when we have hare object property, and
 *                                      unioned when we have proper object property.
 *
 * * Implementation note:
 * * Atomic class is also added using candidate class. If the object property is empty = SharedDataHolder.noneOWLObjProp then it is atomic class.
 * * it must be the same procedure in both
 *      1. Printing getAsString(
 *      2. calculating accuracy,
 *      3. making getAsOWLClassExpression(
 *  * We will have a single group for a single objectProperty.

        Grammer:
        CandidateSolution = (GroupedCandidateClasses) ( AND GroupedCandidateClasses)*
        ------------
        GroupedCandidateClasses = (CandidateClass) ( AND CandidateClass)* |
                                = SOME objProp DOT (CandidateClassWithProp) ( OR CandidateClassWithProp)*
        ------------
        CandidateClass =  (ConjunctiveHornClause) ( AND ConjunctiveHornClause)* | // without object properties and without bracket
                         "(" (ConjunctiveHornClause) ( AND ConjunctiveHornClause)* ")" | // without object properties and with bracket, if there exist AND then the first
                                                                    "(" should not be consumed here. It is becoming conflicting with ConjunctiveHornClause = "(" PosClasses AND NegClasses ")" for test case 7.
                                                                     By putting and extra parenthesis on test case 7, this rule will work.
        ------------
        CandidateClassWithProp = "(" (ConjunctiveHornClause) ( OR ConjunctiveHornClause)* ")" | // with object properties and with bracket
        --------------
        ConjunctiveHornClause = PosClasses |
                              = PosClasses AND NegClasses |   // lookahead ?? how much? For test case: (A1 ⊓ ¬(D1)) it will try to execute ConjunctiveHornClause = PosClasses,
                                                            rather than this rule, if lookahead is not enforced. lookAhead should be no. of PosClass Limit + 2 (AND NOT)
                              = "(" PosClasses AND NegClasses ")"
        --------------
        PosClasses = PosClass |
                   =  PosClass ( AND PosClass)*    // lookahead 2, 1 for AND, 1 for NOT, so 1+1=2
        NegClasses = NOT "(" NegClass ")"|
                   = NOT "(" NegClass ( OR NegClass )* ")" // lookahead 1

*
* test-case
*   1: A ⊓ B
*   2: R.(A ⊓ B)
*   3. (A1 ⊓ ¬(D1))
*   4: (A1 ⊓ ¬(D1)) ⊓ (A2 ⊓ ¬(D1))
*   5: R.( (A1 ⊓ ¬(D1)) ⊔ (A2 ⊓ ¬(D1)) )
*   6. A ⊓ B ⊓ R2.( (A1 ⊓ ¬(D1)) ⊔ (A2 ⊓ ¬(D1)) )
*   7. (A1 ⊓ ¬(D1)) ⊓ (A2 ⊓ ¬(D1))  ⊓  R1.( (B1 ⊓ ... ⊓ Bn ⊓ ¬(D1 ⊔...⊔ Djk)) ⊔ (B1 ⊓ ... ⊓ Bn ⊓ ¬(D1 ⊔...⊔ Djk)) ) ⊓ R2.(..)
*   7... ( (A1 ⊓ ¬(D1)) ⊓ (A2 ⊓ ¬(D1)) ) ⊓  R1.( (B1 ⊓ ... ⊓ Bn ⊓ ¬(D1 ⊔...⊔ Djk)) ⊔ (B1 ⊓ ... ⊓ Bn ⊓ ¬(D1 ⊔...⊔ Djk)) ) ⊓ R2.(..)
*   8. A
     </pre>
 */
  final public 
CandidateSolutionV1 parseCandidateSolution() throws ParseException {CandidateSolutionV1 candidateSolution = new CandidateSolutionV1(reasoner,ontology);
    ArrayList<CandidateClassV1> candidateClasses = new ArrayList<CandidateClassV1>();
    candidateClasses = GroupedCandidateClasses();
if(null != candidateClasses) for(CandidateClassV1 c1: candidateClasses) candidateSolution.addCandidateClass(c1);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case AND:{
        ;
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      jj_consume_token(AND);
      candidateClasses = GroupedCandidateClasses();
if(null != candidateClasses) for(CandidateClassV1 c1: candidateClasses) candidateSolution.addCandidateClass(c1);
    }
    jj_consume_token(0);
{if ("" != null) return candidateSolution;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<CandidateClassV1> GroupedCandidateClasses() throws ParseException {ArrayList<CandidateClassV1> candidateClasses = new ArrayList<CandidateClassV1>();
    CandidateClassV1 candidateClass;
    OWLObjectProperty owlObjectProperty;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SOME:{
      jj_consume_token(SOME);
      owlObjectProperty = parseObjectPropertyId();
      jj_consume_token(DOT);
      candidateClass = parseCandidateClassWithProp(owlObjectProperty);
if(null != candidateClass) candidateClasses.add(candidateClass);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OR:{
          ;
          break;
          }
        default:
          jj_la1[1] = jj_gen;
          break label_2;
        }
        jj_consume_token(OR);
        candidateClass = parseCandidateClassWithProp(owlObjectProperty);
if(null != candidateClass) candidateClasses.add(candidateClass);
      }
      break;
      }
    case OPENPAR:
    case ID:{
      candidateClass = parseCandidateClass(SharedDataHolder.noneOWLObjProp);
if(null != candidateClass) candidateClasses.add(candidateClass);
      label_3:
      while (true) {
        if (jj_2_1(2)) {
          ;
        } else {
          break label_3;
        }
        jj_consume_token(AND);
        candidateClass = parseCandidateClass(SharedDataHolder.noneOWLObjProp);
if(null != candidateClass) candidateClasses.add(candidateClass);
      }
      break;
      }
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return candidateClasses;}
    throw new Error("Missing return statement in function");
  }

  final public CandidateClassV1 parseCandidateClassWithProp(OWLObjectProperty owlObjectProperty) throws ParseException {CandidateClassV1 candidateClass = new CandidateClassV1(owlObjectProperty,reasoner,ontology);
    ConjunctiveHornClauseV1 conjunctiveHornClause;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case OPENPAR:{
      jj_consume_token(OPENPAR);
      break;
      }
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    conjunctiveHornClause = parseConjunctiveHornClause(owlObjectProperty);
candidateClass.addConjunctiveHornClauses(conjunctiveHornClause);
    label_4:
    while (true) {
      if (jj_2_2(2)) {
        ;
      } else {
        break label_4;
      }
      jj_consume_token(OR);
      conjunctiveHornClause = parseConjunctiveHornClause(owlObjectProperty);
candidateClass.addConjunctiveHornClauses(conjunctiveHornClause);
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CLOSEPAR:{
      jj_consume_token(CLOSEPAR);
      break;
      }
    default:
      jj_la1[4] = jj_gen;
      ;
    }
{if ("" != null) return candidateClass;}
    throw new Error("Missing return statement in function");
  }

  final public CandidateClassV1 parseCandidateClass(OWLObjectProperty owlObjectProperty) throws ParseException {CandidateClassV1 candidateClass = new CandidateClassV1(owlObjectProperty,reasoner,ontology);
    ConjunctiveHornClauseV1 conjunctiveHornClause;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case OPENPAR:{
      jj_consume_token(OPENPAR);
      break;
      }
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    conjunctiveHornClause = parseConjunctiveHornClause(owlObjectProperty);
candidateClass.addConjunctiveHornClauses(conjunctiveHornClause);
    label_5:
    while (true) {
      if (jj_2_3(2)) {
        ;
      } else {
        break label_5;
      }
      jj_consume_token(AND);
      conjunctiveHornClause = parseConjunctiveHornClause(owlObjectProperty);
candidateClass.addConjunctiveHornClauses(conjunctiveHornClause);
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CLOSEPAR:{
      jj_consume_token(CLOSEPAR);
      break;
      }
    default:
      jj_la1[6] = jj_gen;
      ;
    }
{if ("" != null) return candidateClass;}
    throw new Error("Missing return statement in function");
  }

  final public ConjunctiveHornClauseV1 parseConjunctiveHornClause(OWLObjectProperty owlObjectProperty) throws ParseException {ConjunctiveHornClauseV1 conjunctiveHornClause = new ConjunctiveHornClauseV1(owlObjectProperty,reasoner,ontology);
    ArrayList<OWLClassExpression> posTypes = new ArrayList<OWLClassExpression>();
    ArrayList<OWLClassExpression> negTypes = new ArrayList<OWLClassExpression>();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case OPENPAR:{
      jj_consume_token(OPENPAR);
      break;
      }
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case OPENPAR:{
      jj_consume_token(OPENPAR);
      break;
      }
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    posTypes = parsePosClasses();
conjunctiveHornClause.setPosObjectTypes(posTypes);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CLOSEPAR:{
      jj_consume_token(CLOSEPAR);
      break;
      }
    default:
      jj_la1[9] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case AND:{
      jj_consume_token(AND);
      jj_consume_token(NOT);
      jj_consume_token(OPENPAR);
      negTypes = parseNegClasses();
conjunctiveHornClause.setNegObjectTypes(negTypes);
      jj_consume_token(CLOSEPAR);
      break;
      }
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CLOSEPAR:{
      jj_consume_token(CLOSEPAR);
      break;
      }
    default:
      jj_la1[11] = jj_gen;
      ;
    }
{if ("" != null) return conjunctiveHornClause;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<OWLClassExpression> parsePosClasses() throws ParseException {ArrayList<OWLClassExpression> posTypes = new ArrayList<OWLClassExpression>();
    OWLClassExpression owlClassExpression;
    owlClassExpression = parseClassId();
posTypes.add(owlClassExpression);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case AND:{
        ;
        break;
        }
      default:
        jj_la1[12] = jj_gen;
        break label_6;
      }
      jj_consume_token(AND);
      owlClassExpression = parseClassId();
posTypes.add(owlClassExpression);
    }
{if ("" != null) return posTypes;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<OWLClassExpression> parseNegClasses() throws ParseException {ArrayList<OWLClassExpression> negTypes = new ArrayList<OWLClassExpression>();
    OWLClassExpression owlClassExpression;
    owlClassExpression = parseClassId();
negTypes.add(owlClassExpression);
    label_7:
    while (true) {
      if (jj_2_4(2)) {
        ;
      } else {
        break label_7;
      }
      jj_consume_token(OR);
      owlClassExpression = parseClassId();
negTypes.add(owlClassExpression);
    }
{if ("" != null) return negTypes;}
    throw new Error("Missing return statement in function");
  }

  final public OWLObjectProperty parseObjectPropertyId() throws ParseException {IRI iri;
    boolean inverse = false;
    iri = parseId();
{if ("" != null) return factory.getOWLObjectProperty(iri);}
    throw new Error("Missing return statement in function");
  }

  final public OWLClass parseClassId() throws ParseException {IRI iri;
    iri = parseId();
{if ("" != null) return factory.getOWLClass(iri);}
    throw new Error("Missing return statement in function");
  }

  final public IRI parseId() throws ParseException {Token t;
    t = jj_consume_token(ID);
{if ("" != null) return getIRIFromId(t.image);}
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_3R_10()
 {
    if (jj_3R_12()) return true;
    return false;
  }

  private boolean jj_3R_11()
 {
    if (jj_3R_10()) return true;
    return false;
  }

  private boolean jj_3_4()
 {
    if (jj_scan_token(OR)) return true;
    if (jj_3R_10()) return true;
    return false;
  }

  private boolean jj_3_2()
 {
    if (jj_scan_token(OR)) return true;
    if (jj_3R_9()) return true;
    return false;
  }

  private boolean jj_3R_9()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(10)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(10)) jj_scanpos = xsp;
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3_1()
 {
    if (jj_scan_token(AND)) return true;
    if (jj_3R_8()) return true;
    return false;
  }

  private boolean jj_3_3()
 {
    if (jj_scan_token(AND)) return true;
    if (jj_3R_9()) return true;
    return false;
  }

  private boolean jj_3R_12()
 {
    if (jj_scan_token(ID)) return true;
    return false;
  }

  private boolean jj_3R_8()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(10)) jj_scanpos = xsp;
    if (jj_3R_9()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public SimpleParserJavacc_v6TokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[13];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x20000,0x40000,0x20100400,0x400,0x800,0x400,0x800,0x400,0x400,0x800,0x20000,0x800,0x20000,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[4];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public SimpleParserJavacc_v6(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SimpleParserJavacc_v6(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SimpleParserJavacc_v6TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public SimpleParserJavacc_v6(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new SimpleParserJavacc_v6TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public SimpleParserJavacc_v6(SimpleParserJavacc_v6TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(SimpleParserJavacc_v6TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[30];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 13; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 30; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 4; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
